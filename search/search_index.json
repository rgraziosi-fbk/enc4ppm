{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Encoding For Predictive Process Monitoring (enc4ppm)","text":"<p><code>enc4ppm</code> is a Python package than provides common process mining encodings.</p>"},{"location":"#installation","title":"Installation","text":"<p>Using pip:</p> <pre><code>pip install enc4ppm\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>The following example performs frequency encoding with latest payload for next activity prediction task:</p> <pre><code>import pandas as pd\n\nfrom enc4ppm.frequency_encoder import FrequencyEncoder\nfrom enc4ppm.constants import LabelingType\n\n# Load log\nlog = pd.read_csv('bpic2012.csv')\n\n# Create encoder\nencoder = FrequencyEncoder(\n    labeling_type=LabelingType.NEXT_ACTIVITY,\n    include_latest_payload=True,\n    attributes=['AMOUNT_REQ'],\n)\n\n# Encode log\nencoded_log = encoder.encode(log)\n</code></pre>"},{"location":"example/","title":"Usage Example","text":"<p>This page provides example usage of the <code>enc4ppm</code> package.</p>"},{"location":"reference/complex_index_encoder/","title":"ComplexIndexEncoder Module API Reference","text":""},{"location":"reference/complex_index_encoder/#enc4ppm.complex_index_encoder.ComplexIndexEncoder","title":"<code>ComplexIndexEncoder</code>","text":"<p>               Bases: <code>BaseEncoder</code></p> Source code in <code>src/enc4ppm/complex_index_encoder.py</code> <pre><code>class ComplexIndexEncoder(BaseEncoder):\n    def __init__(\n        self,\n        include_timestamps: bool = False,\n        *,\n        labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n        attributes: list[str] | str = [],\n        categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n        numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n        prefix_length: int = None,\n        prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n        add_time_features: bool = False,\n        timestamp_format: str = None,\n        case_id_key: str = 'case:concept:name',\n        activity_key: str = 'concept:name',\n        timestamp_key: str = 'time:timestamp',\n        outcome_key: str = 'outcome',\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ComplexIndexEncoder.\n\n        Args:\n            include_timestamps: Whether to add Timestamp columns or not.\n            labeling_type: Label type to apply to examples.\n            attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n            categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n            numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n            prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n            prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n            add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n            timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n            case_id_key: Column name for case identifiers.\n            activity_key: Column name for activity names.\n            timestamp_key: Column name for timestamps.\n            outcome_key: Column name for outcome predition.\n        \"\"\"\n        super().__init__(\n            labeling_type,\n            attributes,\n            categorical_encoding,\n            numerical_scaling,\n            prefix_length,\n            prefix_strategy,\n            add_time_features,\n            timestamp_format,\n            case_id_key,\n            activity_key,\n            timestamp_key,\n            outcome_key,\n        )\n\n        self.include_timestamps = include_timestamps\n\n\n    def encode(\n        self,\n        df: pd.DataFrame,\n        *,\n        freeze: bool = False,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Encode the provided DataFrame with complex-index encoding and apply the specified labeling.\n\n        Args:\n            df: DataFrame to encode.\n            freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n        Returns:\n            The encoded DataFrame.\n        \"\"\"\n        return super()._encode_template(df, freeze=freeze)\n\n\n    def _encode(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        rows = []\n        grouped = df.groupby(self.case_id_key)\n\n        for case_id, case_events in grouped:\n            case_events = case_events.sort_values(self.timestamp_key).reset_index()\n\n            for prefix_length in range(1, len(case_events)+1):\n                row = {\n                    self.case_id_key: case_id,\n                    self.timestamp_key: case_events.loc[prefix_length-1, self.timestamp_key],\n                    self.ORIGINAL_INDEX_KEY: case_events.loc[prefix_length-1, 'index'],\n                }\n\n                # Add trace attributes\n                for attribute_name, attribute in self.log_attributes.items():\n                    if attribute['scope'] != 'trace': continue\n\n                    row[attribute_name] = self._get_attribute_value(attribute_name, case_events.loc[prefix_length-1, attribute_name])\n\n                # Add activities\n                for i in range(1, self.prefix_length+1):\n                    if i &lt;= prefix_length:\n                        row[f'{self.EVENT_COL_PREFIX_NAME}_{i}'] = self._get_activity_value(case_events.loc[i-1, self.activity_key])\n                    else:\n                        row[f'{self.EVENT_COL_PREFIX_NAME}_{i}'] = self.PADDING_CAT_VAL\n\n                # Add timestamps\n                if self.include_timestamps:\n                    for i in range(1, self.prefix_length+1):\n                        if i &lt;= prefix_length:\n                            row[f'{self.TIMESTAMP_COL_PREFIX_NAME}_{i}'] = case_events.loc[i-1, self.timestamp_key]\n                        else:\n                            row[f'{self.TIMESTAMP_COL_PREFIX_NAME}_{i}'] = pd.NaT\n\n                # Add event attributes\n                for attribute_name, attribute in self.log_attributes.items():\n                    if attribute['scope'] != 'event': continue\n\n                    for i in range(1, self.prefix_length+1):\n                        if i &lt;= prefix_length:\n                            row[f'{attribute_name}_{i}'] = self._get_attribute_value(attribute_name, case_events.loc[i-1, attribute_name])\n                        else:\n                            if attribute['type'] == 'categorical':\n                                row[f'{attribute_name}_{i}'] = self.PADDING_CAT_VAL\n                            else:\n                                row[f'{attribute_name}_{i}'] = self.PADDING_NUM_VAL\n\n                rows.append(row)\n\n        encoded_df = pd.DataFrame(rows)\n\n        # Transform to one-hot if requested\n        if self.categorical_encoding == CategoricalEncoding.ONE_HOT:\n            categorical_columns = []\n            categorical_columns_possible_values = []\n\n            # Activity columns\n            for i in range(1, self.prefix_length+1):\n                categorical_columns.append(f'{self.EVENT_COL_PREFIX_NAME}_{i}')\n                categorical_columns_possible_values.append(self.log_activities)\n\n            # Categorical attributes columns\n            for attribute_name, attribute in self.log_attributes.items():\n                if attribute['type'] == 'categorical':\n                    if attribute['scope'] == 'event':\n                        for i in range(1, self.prefix_length+1):\n                            categorical_columns.append(f'{attribute_name}_{i}')\n                            categorical_columns_possible_values.append(attribute['values'])\n                    else:\n                        # For trace attributes do not consider PADDING value\n                        attribute_possible_values = [attribute_value for attribute_value in attribute['values'] if attribute_value != self.PADDING_CAT_VAL]\n\n                        categorical_columns.append(attribute_name)\n                        categorical_columns_possible_values.append(attribute_possible_values)\n\n            encoded_df = one_hot(\n                encoded_df,\n                columns=categorical_columns,\n                columns_possible_values=categorical_columns_possible_values,\n                unknown_value=self.UNKNOWN_VAL,\n            )\n\n        return encoded_df\n</code></pre>"},{"location":"reference/complex_index_encoder/#enc4ppm.complex_index_encoder.ComplexIndexEncoder.__init__","title":"<code>__init__(include_timestamps=False, *, labeling_type=LabelingType.NEXT_ACTIVITY, attributes=[], categorical_encoding=CategoricalEncoding.STRING, numerical_scaling=NumericalScaling.NONE, prefix_length=None, prefix_strategy=PrefixStrategy.UP_TO_SPECIFIED, add_time_features=False, timestamp_format=None, case_id_key='case:concept:name', activity_key='concept:name', timestamp_key='time:timestamp', outcome_key='outcome')</code>","text":"<p>Initialize the ComplexIndexEncoder.</p> <p>Parameters:</p> Name Type Description Default <code>include_timestamps</code> <code>bool</code> <p>Whether to add Timestamp columns or not.</p> <code>False</code> <code>labeling_type</code> <code>LabelingType</code> <p>Label type to apply to examples.</p> <code>NEXT_ACTIVITY</code> <code>attributes</code> <code>list[str] | str</code> <p>Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).</p> <code>[]</code> <code>categorical_encoding</code> <code>CategoricalEncoding</code> <p>How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <code>numerical_scaling</code> <code>NumericalScaling</code> <p>How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).</p> <code>NONE</code> <code>prefix_length</code> <code>int</code> <p>Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.</p> <code>None</code> <code>prefix_strategy</code> <code>PrefixStrategy</code> <p>Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).</p> <code>UP_TO_SPECIFIED</code> <code>add_time_features</code> <code>bool</code> <p>Whether to add time features (time since case start and time since last event) to the encoding.</p> <code>False</code> <code>timestamp_format</code> <code>str</code> <p>Format of the timestamps in the log. If not provided, formatting will be inferred from the data.</p> <code>None</code> <code>case_id_key</code> <code>str</code> <p>Column name for case identifiers.</p> <code>'case:concept:name'</code> <code>activity_key</code> <code>str</code> <p>Column name for activity names.</p> <code>'concept:name'</code> <code>timestamp_key</code> <code>str</code> <p>Column name for timestamps.</p> <code>'time:timestamp'</code> <code>outcome_key</code> <code>str</code> <p>Column name for outcome predition.</p> <code>'outcome'</code> Source code in <code>src/enc4ppm/complex_index_encoder.py</code> <pre><code>def __init__(\n    self,\n    include_timestamps: bool = False,\n    *,\n    labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n    attributes: list[str] | str = [],\n    categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n    prefix_length: int = None,\n    prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n    add_time_features: bool = False,\n    timestamp_format: str = None,\n    case_id_key: str = 'case:concept:name',\n    activity_key: str = 'concept:name',\n    timestamp_key: str = 'time:timestamp',\n    outcome_key: str = 'outcome',\n) -&gt; None:\n    \"\"\"\n    Initialize the ComplexIndexEncoder.\n\n    Args:\n        include_timestamps: Whether to add Timestamp columns or not.\n        labeling_type: Label type to apply to examples.\n        attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n        categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n        numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n        prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n        prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n        add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n        timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n        case_id_key: Column name for case identifiers.\n        activity_key: Column name for activity names.\n        timestamp_key: Column name for timestamps.\n        outcome_key: Column name for outcome predition.\n    \"\"\"\n    super().__init__(\n        labeling_type,\n        attributes,\n        categorical_encoding,\n        numerical_scaling,\n        prefix_length,\n        prefix_strategy,\n        add_time_features,\n        timestamp_format,\n        case_id_key,\n        activity_key,\n        timestamp_key,\n        outcome_key,\n    )\n\n    self.include_timestamps = include_timestamps\n</code></pre>"},{"location":"reference/complex_index_encoder/#enc4ppm.complex_index_encoder.ComplexIndexEncoder.encode","title":"<code>encode(df, *, freeze=False)</code>","text":"<p>Encode the provided DataFrame with complex-index encoding and apply the specified labeling.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to encode.</p> required <code>freeze</code> <code>bool</code> <p>Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The encoded DataFrame.</p> Source code in <code>src/enc4ppm/complex_index_encoder.py</code> <pre><code>def encode(\n    self,\n    df: pd.DataFrame,\n    *,\n    freeze: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Encode the provided DataFrame with complex-index encoding and apply the specified labeling.\n\n    Args:\n        df: DataFrame to encode.\n        freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n    Returns:\n        The encoded DataFrame.\n    \"\"\"\n    return super()._encode_template(df, freeze=freeze)\n</code></pre>"},{"location":"reference/frequency_encoder/","title":"FrequencyEncoder Module API Reference","text":""},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder","title":"<code>FrequencyEncoder</code>","text":"<p>               Bases: <code>BaseEncoder</code></p> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>class FrequencyEncoder(BaseEncoder):\n    def __init__(\n        self,\n        *,\n        include_latest_payload: bool = False,\n\n        labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n        attributes: list[str] | str = [],\n        categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n        numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n        prefix_length: int = None,\n        prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n        add_time_features: bool = False,\n        timestamp_format: str = None,\n        case_id_key: str = 'case:concept:name',\n        activity_key: str = 'concept:name',\n        timestamp_key: str = 'time:timestamp',\n        outcome_key: str = 'outcome',\n    ) -&gt; None:\n        \"\"\"\n        Initialize the FrequencyEncoder.\n\n        Args:\n            include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n            labeling_type: Label type to apply to examples.\n            attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n            categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n            numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n            prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n            prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n            add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n            timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n            case_id_key: Column name for case identifiers.\n            activity_key: Column name for activity names.\n            timestamp_key: Column name for timestamps.\n            outcome_key: Column name for outcome predition.\n        \"\"\"\n        super().__init__(\n            labeling_type,\n            attributes,\n            categorical_encoding,\n            numerical_scaling,\n            prefix_length,\n            prefix_strategy,\n            add_time_features,\n            timestamp_format,\n            case_id_key,\n            activity_key,\n            timestamp_key,\n            outcome_key,\n        )\n\n        self.include_latest_payload = include_latest_payload\n\n\n    def encode(\n        self,\n        df: pd.DataFrame,\n        *,\n        freeze: bool = False,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Encode the provided DataFrame with frequency encoding and apply the specified labeling.\n\n        Args:\n            df: DataFrame to encode.\n            freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n        Returns:\n            The encoded DataFrame.\n        \"\"\"\n        return super()._encode_template(df, freeze=freeze)\n\n\n    def _encode(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        rows = []\n        grouped = df.groupby(self.case_id_key)\n\n        for case_id, case_events in grouped:\n            case_events = case_events.sort_values(self.timestamp_key)\n\n            for prefix_length in range(1, len(case_events)+1):\n                prefix = case_events.iloc[:prefix_length]\n                counts = prefix[self.activity_key].value_counts()\n\n                row = {\n                    self.case_id_key: case_id,\n                    self.timestamp_key: prefix.iloc[-1][self.timestamp_key],\n                    self.ORIGINAL_INDEX_KEY: prefix.index[-1],\n                }\n\n                for activity in self.log_activities[:-1]:\n                    row[activity] = counts.get(activity, 0)\n\n                # Handle unknown activities\n                row[self.UNKNOWN_VAL] = sum(counts.get(activity, 0) for activity in counts.index if activity not in self.log_activities[:-1])\n\n                rows.append(row)\n\n        encoded_df = pd.DataFrame(rows)\n\n        if self.include_latest_payload:\n            encoded_df = super()._include_latest_payload(encoded_df)\n\n        # Transform to one-hot if requested\n        if self.categorical_encoding == CategoricalEncoding.ONE_HOT:\n            categorical_columns = []\n            categorical_columns_possible_values = []\n\n            if self.include_latest_payload:\n                for attribute_name, attribute in self.log_attributes.items():\n                    if attribute['type'] == 'categorical':\n                        # For latest payload do not consider PADDING value\n                        attribute_possible_values = [attribute_value for attribute_value in attribute['values'] if attribute_value != self.PADDING_CAT_VAL]\n\n                        categorical_columns.append(f'{attribute_name}_{self.LATEST_PAYLOAD_COL_SUFFIX_NAME}')\n                        categorical_columns_possible_values.append(attribute_possible_values)\n\n            encoded_df = one_hot(\n                encoded_df,\n                columns=categorical_columns,\n                columns_possible_values=categorical_columns_possible_values,\n                unknown_value=self.UNKNOWN_VAL,\n            )\n\n        return encoded_df\n</code></pre>"},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder.__init__","title":"<code>__init__(*, include_latest_payload=False, labeling_type=LabelingType.NEXT_ACTIVITY, attributes=[], categorical_encoding=CategoricalEncoding.STRING, numerical_scaling=NumericalScaling.NONE, prefix_length=None, prefix_strategy=PrefixStrategy.UP_TO_SPECIFIED, add_time_features=False, timestamp_format=None, case_id_key='case:concept:name', activity_key='concept:name', timestamp_key='time:timestamp', outcome_key='outcome')</code>","text":"<p>Initialize the FrequencyEncoder.</p> <p>Parameters:</p> Name Type Description Default <code>include_latest_payload</code> <code>bool</code> <p>Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the <code>attributes</code> parameter.</p> <code>False</code> <code>labeling_type</code> <code>LabelingType</code> <p>Label type to apply to examples.</p> <code>NEXT_ACTIVITY</code> <code>attributes</code> <code>list[str] | str</code> <p>Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).</p> <code>[]</code> <code>categorical_encoding</code> <code>CategoricalEncoding</code> <p>How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <code>numerical_scaling</code> <code>NumericalScaling</code> <p>How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).</p> <code>NONE</code> <code>prefix_length</code> <code>int</code> <p>Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.</p> <code>None</code> <code>prefix_strategy</code> <code>PrefixStrategy</code> <p>Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).</p> <code>UP_TO_SPECIFIED</code> <code>add_time_features</code> <code>bool</code> <p>Whether to add time features (time since case start and time since last event) to the encoding.</p> <code>False</code> <code>timestamp_format</code> <code>str</code> <p>Format of the timestamps in the log. If not provided, formatting will be inferred from the data.</p> <code>None</code> <code>case_id_key</code> <code>str</code> <p>Column name for case identifiers.</p> <code>'case:concept:name'</code> <code>activity_key</code> <code>str</code> <p>Column name for activity names.</p> <code>'concept:name'</code> <code>timestamp_key</code> <code>str</code> <p>Column name for timestamps.</p> <code>'time:timestamp'</code> <code>outcome_key</code> <code>str</code> <p>Column name for outcome predition.</p> <code>'outcome'</code> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>def __init__(\n    self,\n    *,\n    include_latest_payload: bool = False,\n\n    labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n    attributes: list[str] | str = [],\n    categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n    prefix_length: int = None,\n    prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n    add_time_features: bool = False,\n    timestamp_format: str = None,\n    case_id_key: str = 'case:concept:name',\n    activity_key: str = 'concept:name',\n    timestamp_key: str = 'time:timestamp',\n    outcome_key: str = 'outcome',\n) -&gt; None:\n    \"\"\"\n    Initialize the FrequencyEncoder.\n\n    Args:\n        include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n        labeling_type: Label type to apply to examples.\n        attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n        categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n        numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n        prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n        prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n        add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n        timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n        case_id_key: Column name for case identifiers.\n        activity_key: Column name for activity names.\n        timestamp_key: Column name for timestamps.\n        outcome_key: Column name for outcome predition.\n    \"\"\"\n    super().__init__(\n        labeling_type,\n        attributes,\n        categorical_encoding,\n        numerical_scaling,\n        prefix_length,\n        prefix_strategy,\n        add_time_features,\n        timestamp_format,\n        case_id_key,\n        activity_key,\n        timestamp_key,\n        outcome_key,\n    )\n\n    self.include_latest_payload = include_latest_payload\n</code></pre>"},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder.encode","title":"<code>encode(df, *, freeze=False)</code>","text":"<p>Encode the provided DataFrame with frequency encoding and apply the specified labeling.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to encode.</p> required <code>freeze</code> <code>bool</code> <p>Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The encoded DataFrame.</p> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>def encode(\n    self,\n    df: pd.DataFrame,\n    *,\n    freeze: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Encode the provided DataFrame with frequency encoding and apply the specified labeling.\n\n    Args:\n        df: DataFrame to encode.\n        freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n    Returns:\n        The encoded DataFrame.\n    \"\"\"\n    return super()._encode_template(df, freeze=freeze)\n</code></pre>"},{"location":"reference/simple_index_encoder/","title":"SimpleIndexEncoder Module API Reference","text":""},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder","title":"<code>SimpleIndexEncoder</code>","text":"<p>               Bases: <code>BaseEncoder</code></p> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>class SimpleIndexEncoder(BaseEncoder):\n    def __init__(\n        self,\n        *,\n        include_latest_payload: bool = False,\n\n        labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n        attributes: list[str] | str = [],\n        categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n        numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n        prefix_length: int = None,\n        prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n        add_time_features: bool = False,\n        timestamp_format: str = None,\n        case_id_key: str = 'case:concept:name',\n        activity_key: str = 'concept:name',\n        timestamp_key: str = 'time:timestamp',\n        outcome_key: str = 'outcome',\n    ) -&gt; None:\n        \"\"\"\n        Initialize the SimpleIndexEncoder.\n\n        Args:\n            include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n            labeling_type: Label type to apply to examples.\n            attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n            categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n            numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n            prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n            prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n            add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n            timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n            case_id_key: Column name for case identifiers.\n            activity_key: Column name for activity names.\n            timestamp_key: Column name for timestamps.\n            outcome_key: Column name for outcome predition.\n        \"\"\"\n        super().__init__(\n            labeling_type,\n            attributes,\n            categorical_encoding,\n            numerical_scaling,\n            prefix_length,\n            prefix_strategy,\n            add_time_features,\n            timestamp_format,\n            case_id_key,\n            activity_key,\n            timestamp_key,\n            outcome_key,\n        )\n\n        self.include_latest_payload = include_latest_payload\n\n\n    def encode(\n        self,\n        df: pd.DataFrame,\n        *,\n        freeze: bool = False,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Encode the provided DataFrame with simple-index encoding and apply the specified labeling.\n\n        Args:\n            df: DataFrame to encode.\n            freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n        Returns:\n            The encoded DataFrame.\n        \"\"\"\n        return super()._encode_template(df, freeze=freeze)\n\n\n    def _encode(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        rows = []\n        grouped = df.groupby(self.case_id_key)\n\n        for case_id, case_events in grouped:\n            case_events = case_events.sort_values(self.timestamp_key).reset_index()\n\n            for prefix_length in range(1, len(case_events)+1):\n                row = {\n                    self.case_id_key: case_id,\n                    self.timestamp_key: case_events.loc[prefix_length-1, self.timestamp_key],\n                    self.ORIGINAL_INDEX_KEY: case_events.loc[prefix_length-1, 'index'],\n                }\n\n                for i in range(1, self.prefix_length+1):\n                    if i &lt;= prefix_length:\n                        row[f'{self.EVENT_COL_PREFIX_NAME}_{i}'] = self._get_activity_value(case_events.loc[i-1, self.activity_key])\n                    else:\n                        row[f'{self.EVENT_COL_PREFIX_NAME}_{i}'] = self.PADDING_CAT_VAL\n\n                rows.append(row)\n\n        encoded_df = pd.DataFrame(rows)\n\n        if self.include_latest_payload:\n            encoded_df = super()._include_latest_payload(encoded_df)\n\n        # Transform to one-hot if requested\n        if self.categorical_encoding == CategoricalEncoding.ONE_HOT:\n            categorical_columns = []\n            categorical_columns_possible_values = []\n\n            # Activity columns\n            for i in range(1, self.prefix_length+1):\n                categorical_columns.append(f'{self.EVENT_COL_PREFIX_NAME}_{i}')\n                categorical_columns_possible_values.append(self.log_activities)\n\n            # Latest payload columns\n            if self.include_latest_payload:\n                for attribute_name, attribute in self.log_attributes.items():\n                    if attribute['type'] == 'categorical':\n                        # For latest payload do not consider PADDING value\n                        attribute_possible_values = [attribute_value for attribute_value in attribute['values'] if attribute_value != self.PADDING_CAT_VAL]\n\n                        categorical_columns.append(f'{attribute_name}_{self.LATEST_PAYLOAD_COL_SUFFIX_NAME}')\n                        categorical_columns_possible_values.append(attribute_possible_values)\n\n            encoded_df = one_hot(\n                encoded_df,\n                columns=categorical_columns,\n                columns_possible_values=categorical_columns_possible_values,\n                unknown_value=self.UNKNOWN_VAL,\n            )\n\n        return encoded_df\n</code></pre>"},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder.__init__","title":"<code>__init__(*, include_latest_payload=False, labeling_type=LabelingType.NEXT_ACTIVITY, attributes=[], categorical_encoding=CategoricalEncoding.STRING, numerical_scaling=NumericalScaling.NONE, prefix_length=None, prefix_strategy=PrefixStrategy.UP_TO_SPECIFIED, add_time_features=False, timestamp_format=None, case_id_key='case:concept:name', activity_key='concept:name', timestamp_key='time:timestamp', outcome_key='outcome')</code>","text":"<p>Initialize the SimpleIndexEncoder.</p> <p>Parameters:</p> Name Type Description Default <code>include_latest_payload</code> <code>bool</code> <p>Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the <code>attributes</code> parameter.</p> <code>False</code> <code>labeling_type</code> <code>LabelingType</code> <p>Label type to apply to examples.</p> <code>NEXT_ACTIVITY</code> <code>attributes</code> <code>list[str] | str</code> <p>Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).</p> <code>[]</code> <code>categorical_encoding</code> <code>CategoricalEncoding</code> <p>How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <code>numerical_scaling</code> <code>NumericalScaling</code> <p>How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).</p> <code>NONE</code> <code>prefix_length</code> <code>int</code> <p>Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.</p> <code>None</code> <code>prefix_strategy</code> <code>PrefixStrategy</code> <p>Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).</p> <code>UP_TO_SPECIFIED</code> <code>add_time_features</code> <code>bool</code> <p>Whether to add time features (time since case start and time since last event) to the encoding.</p> <code>False</code> <code>timestamp_format</code> <code>str</code> <p>Format of the timestamps in the log. If not provided, formatting will be inferred from the data.</p> <code>None</code> <code>case_id_key</code> <code>str</code> <p>Column name for case identifiers.</p> <code>'case:concept:name'</code> <code>activity_key</code> <code>str</code> <p>Column name for activity names.</p> <code>'concept:name'</code> <code>timestamp_key</code> <code>str</code> <p>Column name for timestamps.</p> <code>'time:timestamp'</code> <code>outcome_key</code> <code>str</code> <p>Column name for outcome predition.</p> <code>'outcome'</code> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>def __init__(\n    self,\n    *,\n    include_latest_payload: bool = False,\n\n    labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n    attributes: list[str] | str = [],\n    categorical_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    numerical_scaling: NumericalScaling = NumericalScaling.NONE,\n    prefix_length: int = None,\n    prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n    add_time_features: bool = False,\n    timestamp_format: str = None,\n    case_id_key: str = 'case:concept:name',\n    activity_key: str = 'concept:name',\n    timestamp_key: str = 'time:timestamp',\n    outcome_key: str = 'outcome',\n) -&gt; None:\n    \"\"\"\n    Initialize the SimpleIndexEncoder.\n\n    Args:\n        include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n        labeling_type: Label type to apply to examples.\n        attributes: Which attributes to consider. Can be a list of the attributes to consider or the string 'all' (all attributes found in the log will be encoded).\n        categorical_encoding: How to encode categorical features. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n        numerical_scaling: How to scale numerical features. They can be standardized (NumericalScaling.STANDARDIZATION) or left as-is (NumericalScaling.NONE).\n        prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n        prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n        add_time_features: Whether to add time features (time since case start and time since last event) to the encoding.\n        timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n        case_id_key: Column name for case identifiers.\n        activity_key: Column name for activity names.\n        timestamp_key: Column name for timestamps.\n        outcome_key: Column name for outcome predition.\n    \"\"\"\n    super().__init__(\n        labeling_type,\n        attributes,\n        categorical_encoding,\n        numerical_scaling,\n        prefix_length,\n        prefix_strategy,\n        add_time_features,\n        timestamp_format,\n        case_id_key,\n        activity_key,\n        timestamp_key,\n        outcome_key,\n    )\n\n    self.include_latest_payload = include_latest_payload\n</code></pre>"},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder.encode","title":"<code>encode(df, *, freeze=False)</code>","text":"<p>Encode the provided DataFrame with simple-index encoding and apply the specified labeling.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to encode.</p> required <code>freeze</code> <code>bool</code> <p>Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The encoded DataFrame.</p> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>def encode(\n    self,\n    df: pd.DataFrame,\n    *,\n    freeze: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Encode the provided DataFrame with simple-index encoding and apply the specified labeling.\n\n    Args:\n        df: DataFrame to encode.\n        freeze: Freeze encoder with provided parameters. Usually set to True when encoding the train log, False otherwise. Required if you want to later save the encoder to a file.\n\n    Returns:\n        The encoded DataFrame.\n    \"\"\"\n    return super()._encode_template(df, freeze=freeze)\n</code></pre>"}]}