{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"enc4ppm","text":"<p>Welcome to the documentation for <code>enc4ppm</code>.</p>"},{"location":"example/","title":"Usage Example","text":"<p>This page provides example usage of the <code>enc4ppm</code> package.</p>"},{"location":"reference/frequency_encoder/","title":"FrequencyEncoder Module API Reference","text":""},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder","title":"<code>FrequencyEncoder</code>","text":"<p>               Bases: <code>BaseEncoder</code></p> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>class FrequencyEncoder(BaseEncoder):\n\n    def __init__(\n        self,\n        *,\n        labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n        prefix_length: int = None,\n        prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n        timestamp_format: str = None,\n        case_id_key: str = 'case:concept:name',\n        activity_key: str = 'concept:name',\n        timestamp_key: str = 'time:timestamp',\n    ) -&gt; None:\n        \"\"\"\n        Initialize the FrequencyEncoder.\n\n        Args:\n            labeling_type: Label type to apply to examples.\n            prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n            prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n            timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n            case_id_key: Column name for case identifiers.\n            activity_key: Column name for activity names.\n            timestamp_key: Column name for timestamps.\n        \"\"\"\n        super().__init__(\n            labeling_type,\n            prefix_length,\n            prefix_strategy,\n            timestamp_format,\n            case_id_key,\n            activity_key,\n            timestamp_key,\n        )\n\n\n    def encode(\n        self,\n        df: pd.DataFrame,\n        include_latest_payload: bool = False,\n        attributes: str | list = 'all',\n        categorical_attributes_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Encode the provided DataFrame with frequency encoding and apply the specified labeling.\n\n        Args:\n            df: DataFrame to encode.\n            include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n            attributes: Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.\n            categorical_attributes_encoding: How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n\n        Returns:\n            The encoded DataFrame.\n        \"\"\"\n        return super()._encode_template(\n            df,\n            include_latest_payload=include_latest_payload,\n            attributes=attributes,\n            categorical_attributes_encoding=categorical_attributes_encoding,\n        )\n\n\n    def _encode(\n        self,\n        df: pd.DataFrame,\n        include_latest_payload: bool,\n        attributes: str | list,\n        categorical_attributes_encoding: CategoricalEncoding,\n    ) -&gt; pd.DataFrame:\n        grouped = df.groupby(self.case_id_key)\n        activities = df[self.activity_key].unique().tolist()\n\n        rows = []\n\n        for case_id, case_events in grouped:\n            case_events = case_events.sort_values(self.timestamp_key)\n\n            for prefix_length in range(1, len(case_events)+1):\n                prefix = case_events.iloc[:prefix_length]\n                counts = prefix[self.activity_key].value_counts()\n\n                row = {\n                    self.case_id_key: case_id,\n                    self.timestamp_key: prefix.iloc[-1][self.timestamp_key],\n                    self.ORIGINAL_INDEX_KEY: prefix.index[-1],\n                }\n\n                for activity in activities:\n                    row[activity] = counts.get(activity, 0)\n\n                rows.append(row)\n\n        encoded_df = pd.DataFrame(rows)\n\n        if include_latest_payload:\n            encoded_df = super()._include_latest_payload(\n                encoded_df,\n                attributes=attributes,\n                categorical_attributes_encoding=categorical_attributes_encoding\n            )\n\n        return encoded_df\n</code></pre>"},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder.__init__","title":"<code>__init__(*, labeling_type=LabelingType.NEXT_ACTIVITY, prefix_length=None, prefix_strategy=PrefixStrategy.UP_TO_SPECIFIED, timestamp_format=None, case_id_key='case:concept:name', activity_key='concept:name', timestamp_key='time:timestamp')</code>","text":"<p>Initialize the FrequencyEncoder.</p> <p>Parameters:</p> Name Type Description Default <code>labeling_type</code> <code>LabelingType</code> <p>Label type to apply to examples.</p> <code>NEXT_ACTIVITY</code> <code>prefix_length</code> <code>int</code> <p>Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.</p> <code>None</code> <code>prefix_strategy</code> <code>PrefixStrategy</code> <p>Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).</p> <code>UP_TO_SPECIFIED</code> <code>timestamp_format</code> <code>str</code> <p>Format of the timestamps in the log. If not provided, formatting will be inferred from the data.</p> <code>None</code> <code>case_id_key</code> <code>str</code> <p>Column name for case identifiers.</p> <code>'case:concept:name'</code> <code>activity_key</code> <code>str</code> <p>Column name for activity names.</p> <code>'concept:name'</code> <code>timestamp_key</code> <code>str</code> <p>Column name for timestamps.</p> <code>'time:timestamp'</code> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>def __init__(\n    self,\n    *,\n    labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n    prefix_length: int = None,\n    prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n    timestamp_format: str = None,\n    case_id_key: str = 'case:concept:name',\n    activity_key: str = 'concept:name',\n    timestamp_key: str = 'time:timestamp',\n) -&gt; None:\n    \"\"\"\n    Initialize the FrequencyEncoder.\n\n    Args:\n        labeling_type: Label type to apply to examples.\n        prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n        prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n        timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n        case_id_key: Column name for case identifiers.\n        activity_key: Column name for activity names.\n        timestamp_key: Column name for timestamps.\n    \"\"\"\n    super().__init__(\n        labeling_type,\n        prefix_length,\n        prefix_strategy,\n        timestamp_format,\n        case_id_key,\n        activity_key,\n        timestamp_key,\n    )\n</code></pre>"},{"location":"reference/frequency_encoder/#enc4ppm.frequency_encoder.FrequencyEncoder.encode","title":"<code>encode(df, include_latest_payload=False, attributes='all', categorical_attributes_encoding=CategoricalEncoding.STRING)</code>","text":"<p>Encode the provided DataFrame with frequency encoding and apply the specified labeling.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to encode.</p> required <code>include_latest_payload</code> <code>bool</code> <p>Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the <code>attributes</code> parameter.</p> <code>False</code> <code>attributes</code> <code>str | list</code> <p>Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.</p> <code>'all'</code> <code>categorical_attributes_encoding</code> <code>CategoricalEncoding</code> <p>How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The encoded DataFrame.</p> Source code in <code>src/enc4ppm/frequency_encoder.py</code> <pre><code>def encode(\n    self,\n    df: pd.DataFrame,\n    include_latest_payload: bool = False,\n    attributes: str | list = 'all',\n    categorical_attributes_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Encode the provided DataFrame with frequency encoding and apply the specified labeling.\n\n    Args:\n        df: DataFrame to encode.\n        include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n        attributes: Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.\n        categorical_attributes_encoding: How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n\n    Returns:\n        The encoded DataFrame.\n    \"\"\"\n    return super()._encode_template(\n        df,\n        include_latest_payload=include_latest_payload,\n        attributes=attributes,\n        categorical_attributes_encoding=categorical_attributes_encoding,\n    )\n</code></pre>"},{"location":"reference/simple_index_encoder/","title":"SimpleIndexEncoder Module API Reference","text":""},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder","title":"<code>SimpleIndexEncoder</code>","text":"<p>               Bases: <code>BaseEncoder</code></p> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>class SimpleIndexEncoder(BaseEncoder):\n    PADDING_VALUE = 'PADDING'\n    EVENT_COL_NAME = 'event'\n\n    def __init__(\n        self,\n        *,\n        labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n        prefix_length: int = None,\n        prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n        timestamp_format: str = None,\n        case_id_key: str = 'case:concept:name',\n        activity_key: str = 'concept:name',\n        timestamp_key: str = 'time:timestamp',\n    ) -&gt; None:\n        \"\"\"\n        Initialize the SimpleIndexEncoder.\n\n        Args:\n            labeling_type: Label type to apply to examples.\n            prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n            prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n            timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n            case_id_key: Column name for case identifiers.\n            activity_key: Column name for activity names.\n            timestamp_key: Column name for timestamps.\n        \"\"\"\n        super().__init__(\n            labeling_type,\n            prefix_length,\n            prefix_strategy,\n            timestamp_format,\n            case_id_key,\n            activity_key,\n            timestamp_key,\n        )\n\n\n    def encode(\n        self,\n        df: pd.DataFrame,\n        *,\n        activity_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n        include_latest_payload: bool = False,\n        attributes: str | list = 'all',\n        categorical_attributes_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Encode the provided DataFrame with simple-index encoding and apply the specified labeling.\n\n        Args:\n            df: DataFrame to encode.\n            activity_encoding: How to encode activity names. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n            include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n            attributes: Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.\n            categorical_attributes_encoding: How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n\n        Returns:\n            The encoded DataFrame.\n        \"\"\"\n        return super()._encode_template(\n            df,\n            activity_encoding=activity_encoding,\n            include_latest_payload=include_latest_payload,\n            attributes=attributes,\n            categorical_attributes_encoding=categorical_attributes_encoding,\n        )\n\n\n    def _encode(\n        self,\n        df: pd.DataFrame,\n        activity_encoding: CategoricalEncoding,\n        include_latest_payload: bool = False,\n        attributes: str | list = 'all',\n        categorical_attributes_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    ) -&gt; pd.DataFrame:\n        grouped = df.groupby(self.case_id_key)\n        max_prefix_length = grouped.size().max()\n\n        rows = []\n\n        for case_id, case_events in grouped:\n            case_events = case_events.sort_values(self.timestamp_key).reset_index()\n\n            for prefix_length in range(1, len(case_events)+1):\n                row = {\n                    self.case_id_key: case_id,\n                    self.timestamp_key: case_events.loc[prefix_length-1, self.timestamp_key],\n                    self.ORIGINAL_INDEX_KEY: case_events.loc[prefix_length-1, 'index'],\n                }\n\n                for i in range(1, min(self.prefix_length, max_prefix_length)+1):\n                    if i &lt;= prefix_length:\n                        row[f'{self.EVENT_COL_NAME}_{i}'] = case_events.loc[i-1, self.activity_key]\n                    else:\n                        row[f'{self.EVENT_COL_NAME}_{i}'] = self.PADDING_VALUE\n\n                rows.append(row)\n\n        encoded_df = pd.DataFrame(rows)\n\n        if activity_encoding == CategoricalEncoding.ONE_HOT:\n            encoded_df = pd.get_dummies(\n                encoded_df,\n                columns=[f'{self.EVENT_COL_NAME}_{i}' for i in range(1, max_prefix_length+1)],\n                drop_first=True,\n            )\n\n        if include_latest_payload:\n            encoded_df = super()._include_latest_payload(\n                encoded_df,\n                attributes=attributes,\n                categorical_attributes_encoding=categorical_attributes_encoding\n            )\n\n        return encoded_df\n</code></pre>"},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder.__init__","title":"<code>__init__(*, labeling_type=LabelingType.NEXT_ACTIVITY, prefix_length=None, prefix_strategy=PrefixStrategy.UP_TO_SPECIFIED, timestamp_format=None, case_id_key='case:concept:name', activity_key='concept:name', timestamp_key='time:timestamp')</code>","text":"<p>Initialize the SimpleIndexEncoder.</p> <p>Parameters:</p> Name Type Description Default <code>labeling_type</code> <code>LabelingType</code> <p>Label type to apply to examples.</p> <code>NEXT_ACTIVITY</code> <code>prefix_length</code> <code>int</code> <p>Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.</p> <code>None</code> <code>prefix_strategy</code> <code>PrefixStrategy</code> <p>Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).</p> <code>UP_TO_SPECIFIED</code> <code>timestamp_format</code> <code>str</code> <p>Format of the timestamps in the log. If not provided, formatting will be inferred from the data.</p> <code>None</code> <code>case_id_key</code> <code>str</code> <p>Column name for case identifiers.</p> <code>'case:concept:name'</code> <code>activity_key</code> <code>str</code> <p>Column name for activity names.</p> <code>'concept:name'</code> <code>timestamp_key</code> <code>str</code> <p>Column name for timestamps.</p> <code>'time:timestamp'</code> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>def __init__(\n    self,\n    *,\n    labeling_type: LabelingType = LabelingType.NEXT_ACTIVITY,\n    prefix_length: int = None,\n    prefix_strategy: PrefixStrategy = PrefixStrategy.UP_TO_SPECIFIED,\n    timestamp_format: str = None,\n    case_id_key: str = 'case:concept:name',\n    activity_key: str = 'concept:name',\n    timestamp_key: str = 'time:timestamp',\n) -&gt; None:\n    \"\"\"\n    Initialize the SimpleIndexEncoder.\n\n    Args:\n        labeling_type: Label type to apply to examples.\n        prefix_length: Maximum prefix length to consider: longer prefixes will be discarded, shorter prefixes may be discarded depending on prefix_strategy parameter. If not provided, defaults to maximum prefix length found in log. If provided, it must be a non-zero positive int number.\n        prefix_strategy: Whether to consider prefix lengths from 1 to prefix_length (PrefixStrategy.UP_TO_SPECIFIED) or only the specified prefix_length (PrefixStrategy.ONLY_SPECIFIED).\n        timestamp_format: Format of the timestamps in the log. If not provided, formatting will be inferred from the data.\n        case_id_key: Column name for case identifiers.\n        activity_key: Column name for activity names.\n        timestamp_key: Column name for timestamps.\n    \"\"\"\n    super().__init__(\n        labeling_type,\n        prefix_length,\n        prefix_strategy,\n        timestamp_format,\n        case_id_key,\n        activity_key,\n        timestamp_key,\n    )\n</code></pre>"},{"location":"reference/simple_index_encoder/#enc4ppm.simple_index_encoder.SimpleIndexEncoder.encode","title":"<code>encode(df, *, activity_encoding=CategoricalEncoding.STRING, include_latest_payload=False, attributes='all', categorical_attributes_encoding=CategoricalEncoding.STRING)</code>","text":"<p>Encode the provided DataFrame with simple-index encoding and apply the specified labeling.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to encode.</p> required <code>activity_encoding</code> <code>CategoricalEncoding</code> <p>How to encode activity names. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <code>include_latest_payload</code> <code>bool</code> <p>Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the <code>attributes</code> parameter.</p> <code>False</code> <code>attributes</code> <code>str | list</code> <p>Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.</p> <code>'all'</code> <code>categorical_attributes_encoding</code> <code>CategoricalEncoding</code> <p>How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).</p> <code>STRING</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The encoded DataFrame.</p> Source code in <code>src/enc4ppm/simple_index_encoder.py</code> <pre><code>def encode(\n    self,\n    df: pd.DataFrame,\n    *,\n    activity_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n    include_latest_payload: bool = False,\n    attributes: str | list = 'all',\n    categorical_attributes_encoding: CategoricalEncoding = CategoricalEncoding.STRING,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Encode the provided DataFrame with simple-index encoding and apply the specified labeling.\n\n    Args:\n        df: DataFrame to encode.\n        activity_encoding: How to encode activity names. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n        include_latest_payload: Whether to include (True) or not (False) the latest values of trace and event attributes. The attributes to consider can be specified through the `attributes` parameter.\n        attributes: Which attributes to consider. Can be either 'all' (all trace and event attributes will be encoded) or a list of the attributes to consider.\n        categorical_attributes_encoding: How to encode categorical attributes. They can either remain strings (CategoricalEncoding.STRING) or be converted to one-hot vectors splitted across multiple columns (CategoricalEncoding.ONE_HOT).\n\n    Returns:\n        The encoded DataFrame.\n    \"\"\"\n    return super()._encode_template(\n        df,\n        activity_encoding=activity_encoding,\n        include_latest_payload=include_latest_payload,\n        attributes=attributes,\n        categorical_attributes_encoding=categorical_attributes_encoding,\n    )\n</code></pre>"}]}